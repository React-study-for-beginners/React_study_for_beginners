<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>한입 크기로 잘라 먹는 리액트 1주차</title>
</head>
<body>
    <h1>1주차 강의 내용</h1>

    <h2>변수와 상수</h2>
    <span>
        let 변수명 = 값; => 변수를 선언하다.
        프로그램 실행 도중에 값을 바꿀 수 있다.
        변수명을 이용하여 출력이 가능하다.

        변수명 규칙
        - 기호 사용 X ( _ , $ 만 사용이 가능하다.)
        - 변수명은 숫자가 아닌 문자로 시작해야한다.
        - 예약어는 피해야한다.

        var도 변수 선언 시 사용할 수 있지만 지양해야 한다.
        - var는 변수 중복 선언이 가능해진다.

        const는 상수를 선언할 때 사용한다.
        상수는 중간에 값을 바꿀 수 없다. => 읽기 전용
        선언과 동시에 초기화가 이루어져야한다. => 선언 이후에 값을 넣을 수 없기 때문이다.
    </span>

    <h2>자료형과 형 변환</h2>
    <span>
        자료형? 값을 성질에 따라 분류해둔 것
        
        [Primitive Data Type 원시 타입]
        Number, String, Boolean, Undefined, Null
        - 한 번에 하나의 값만 가질 수 있다.
        - 하나의 고정된 저장 공간을 이용한다.

        Number 타입에는 숫자뿐만 아니라 Infinity, -Infinity, NaN과 같은 값도 있다.
        String 타입은 "",'',``로 감싸서 사용할 수 있다.
            - ``백틱은 문자열 안에 변수의 값을 넣을 수 있게 해준다. `${변수이름}` => 이를 템플릿 리터럴이라고 한다.
        Boolean 타입은 참 또는 거짓을 저장한다.
        Null 타입은 실제로 대입시켜줘야한다.
            - 의도적으로 값을 넣어두지 않음을 알린다.
        Undefined 타입은 아무런 값의 할당이 없을 시 출력된다.

        [Non-Primitive Data Type 비원시 타입]
        Object, Array, Function
        - 한번에 여러 개의 값을 가질 수 있다.
        - 여러 개의 고정되지 않은 동적 공간을 사용한다.

        형 변환? 값은 유지하면서 자료형은 변경
    </span>

    <h2>연산자</h2>
    <span>
        대입 연산자 =
        산술 연산자 + - * / %
        연결 연산자 "" + ""
        복합 연산자 += -= *= /=
        증감 연산자 ++ -- (변수명 오른쪽에 붙이면 코드가 실행된 후에 증감(후위 연산), 왼쪽에 붙이면 증감시키고 코드 실행(전위 연산))
        논리 연산자 !(not) &&(그리고) ||(또한) 
        비교 연산자 == ===(값과 자료형 모두 같음) > >= < <= !=(같지 않음) !==
        typeof 연산자 반환된 값의 타입이 무엇인지 알려줌
        Null 병합 연산자 ?? 양쪽에 피연산자 중에 null이나 undefined가 아닌 값을 대입함
    </span>

    <h2>조건문</h2>
    <span>
        조건문? 어떤 연산의 결과 참, 거짓에 따라서 각각 다른 명령을 지시
    </span>

    <h2>함수</h2>
    <span>
        매개변수를 이용해서 값을 달리 해줄 수 있다.
        결과값을 반환 받아 사용하고 싶다면 return을 사용한다.  
        함수 내부에 선언한 변수나 상수는 함수 바깥에서는 사용할 수 없다. => 지역변수
        함수 외부에 선언한 변수는 함수 내부에서 접근이 가능하다. => 전역변수
    </span>

    <h2>함수 표현식 & 화살표 함수</h2>
    <span>
        함수 선언식과 함수 표현식의 다른 점은 호이스팅의 차이이다.
        - 호이스팅? 선언된 것들은 런타임 전에 코드 최상단에 있는 것처럼 끌어올려지는 것 (먼저 읽어둠)
        - 함수 표현식은 호이스팅이 일어나지 않는다.
        - 화살표 함수도 호이스팅의 대상이 아니다.
    </span>

    <h2>콜백 함수</h2>
    <span>
        콜백 함수? 함수의 매개변수로 다른 함수를 넘겨준 것
    </span>

    <h2>객체</h2>
    <span>
        객체 생성방법
        1. 생성자 이용 let 이름 = new Obj();
        2. 중괄호 이용 (객체 리터럴) let 이름 = {};

       {key: "value",}   객체는 왼쪽처럼 이루어지는데 이를 "(객체)프로퍼티"라고 한다.

       value에는 어떤 자료형이든 다 들어올 수 있다.

       프로퍼티에 접근하는 방법
       1. 점 표기법 (ex.key1)
       2. 괄호 표기법 (ex["key1"]) => 괄호 표기법은 무조건 키 이름을 문자열로 지정해야 한다.
                                 => 괄호 표기법은 객체의 키를 받아와서 값을 사용하는 함수가 필요할 때 사용이 편리하다.
                                    - 동적인 파라미터를 전달받는 상황
                                    - 키를 꺼내와야하는데 키가 고정적이지 않은 상황

        객체는 const로 선언해도 프로퍼티를 수정하는 행위는 상수 자체를 수정하는 행위가 아니기 때문에 오류 X
        - 상수 자체를 수정하는 행위는 선언된 상수를 대입 연산자로 새로운 객체를 만드는 것

        객체 안에서 메서드를 만들게 되면 그 메서드 안에서는 자기자신(자기가 속한 객체)을 this라고 부를 수 있다.
    </span>

    <h2>배열</h2>
    <span>
        배열? 순서있는 요소들의 집합, 여러 항목이 들어있는 리스트

        배열을 만드는 방법
        1. 생성자 이용 let 배열 이름 = new Array();
        2. 배열 리터럴 이용 let 배열 이름 = [];

        배열도 들어가는 자료형은 상관이 없다.

        배열은 키 대신 인덱스가 붙어, 인덱스로 각각의 값에 접근할 수 있다.
    </span>

    <h2>반복문</h2>
    <span>
        반복문? 특정 명령을 반복해서 수행할 수 있도록 해주는 문법

        for (let i = 0; i <= 5; i++)
        - let i = 0;    => 초기식, 반복의 주체가 되는 변수 선언
        - i <= 5;       => 조건식, 반복이 조건을 만족할 때만 돌아가게 조건 명시
        - i++           => 연산, 반복이 수행될 때마다 할 연산

        for문은 배열을 순회할 때 유용하다.
    </span>

    <h2>배열 내장함수</h2>
    <span>
        forEach : 배열의 모든 요소를 한 번씩 순회
        map : 원본 배열에 모든 요소를 순회하면서 연산 후 리턴된 값들을 따로 배열로 담아 반환 
        includes : 주어진 배열에서 전달받은 인자와 일치하는지 확인
        indexOf : 주어진 배열에서 전달받은 인자와 일치하는 인덱스 번호를 반환 (일치하는 값이 없을 경우 -1 반환)
        findIndex : 배열 내 객체에서 일치하는 인덱스 번호 반환 (일치하는 요소가 두개 이상일 경우 첫번째 인덱스 반환)
        find : 조건에 일치하는 요소 자체에 바로 접근 가능

        filter : 전달한 콜백함수가 ture를 반환하는 모든 요소를 배열로 반환
        slice : n번 째부터 n번 - 1 까지 자름
        concat : 첫번째 명시한 배열 뒤로 concat 메서드에게 전달한 배열을 붙여서 하나의 배열로 다시 반환

        sort : 원본 배열 자체를 정렬 (문자 기준)
        join : 배열의 모든 요소를 문자열 형태로 합침
    </span>

    <script>
        // 형 변환
        let numberA = 12;
        let numberB = 2;
        
        console.log(numberA + numberB); // 14

        let numberC = 12;
        let numberD = "2";
        
        console.log(numberC + numberD); // 122

        let numberE = 12;
        let numberF = "2";
        
        console.log(numberE * numberF); // 24
        console.log(numberE * parseInt(numberF)); // 24 => 명시적 형변환

        // 조건문
        let a = 3;
        if (a >= 4){
            console.log('4 이상 입니다.')
        } else if (a >= 7){
            console.log('7 이상 입니다.')
        } else {
            console.log('4 미만 입니다.')
        }

        let country = 'ko'
        switch(country){
            case 'ko': console.log('한국'); break;
            case 'cn': console.log('중국'); break;
            case 'jp': console.log('일본'); break;
            case 'uk': console.log('영국'); break;
            default: console.log('미분류'); break;
        }    // 체이닝되는 조건이 많은 경우 switch를 사용

        // 함수
        let width1 = 10;
        let height1 = 20;

        let area1 = width1 * height1;

        console.log(area1);

        function getArea(width, height){
            // let width = 10;
            // let height = 20;

            let area = width * height;
            //console.log(area);
            return area;
            // 함수 선언식, 함수 선언 방식의 함수 생성
        }
        // getArea(10 ,20);  함수 호출
        let area2 = getArea(100,200);
        console.log('area2: ', area2);

        // 함수 표현식
        let hello = function(){
            return '안녕하세요';
        };

        const helloText = hello();
        console.log(hello); // f hello(){}
        console.log(helloText); // '안녕하세요'
        
        // 화살표 함수
        let helloA = () => {
            return '안녕하세요';
        }

        let helloB = () => '안녕하세요';

        // 콜백 함수
        function checkMood (mood, goodCallBack, badCallBack){
            if (mood === 'good'){
                goodCallBack();
            } else {
                badCallBack();
            }
        }

        function cry(){
            console.log('action :: cry');
        }

        function sing(){
            console.log('action :: sing');
        }

        function dance(){
            console.log('action :: dance');
        }

        checkMood('good', sing, cry);   // 함수의 파라미터로 함수를 넘김

        // 객체
        let ex = {
            key: "String",
            key1: 1,
            key2: true,
            key3: Undefined,
            key4: [1, 2, 3],
            key5: function(){},
        };

        function getPropertyValue (key){
            return ex[key];
        }

        console.log(getPropertyValue["key1"]);

        // 객체 프로퍼티 추가
        let person = {
            name: '가은',   // 멤버
            age: '21',  
            say: function(){console.log(`안녕 나는 ${this.name}`);}   // 객체 안에 담겨있는 함수를 메서드라고 함
        };

        person.location = '한국';   // 키 이름 = 키 값 대입
        person['gender'] = '여성';
        
        // 객체 프로퍼티 수정
        person.name = '오가은'; // 원래 있던 키 이름 = 수정할 키 값 대입
        person['age'] = 22;
        
        // 객체 프로퍼티 삭제
        delete person.age;
        // delete person["age"];    delete는 객체에서 프로퍼티만 삭제시킬 뿐 메모리 상에선 삭제가 이루어지지 않음

        person.name = null;     // null을 대입하면 객체에서 삭제를 함과 동시에 메모리에서도 삭제가 가능

        // 메서드 호출
        person.say();   // 함수호출과 동일하게 ()까지 써야함

        console.log(person);

        // 객체에 프로퍼티가 존재하는지 확인하는 법
        console.log(`name: ${"name" in person}`);   // in 연산자를 이용, "키 이름" in 객체 이름
        
        // 배열 
        let exArray = [1,"2", true, null, undefined, {}, [], function(){}];

        console.log(exArray[0]) // 배열 요소 접근

        exArray.push(6);    // 배열 요소 추가 (맨 마지막에 추가)

        console.log(exArray.length);    // 배열의 길이

        // 반복문
        for (let i = 0; i <= 5; i++){
            console.log('하잉');
        }

        // 배열 순회
        const arr = ["a", "b", "c"];

        for (let i = 0; i < arr.length; i++){
            console.log(arr[i]);
        }       // a b c

        // 객체 순회
        let personObj = {
            name: "가은",
            age: 21,
            tall: 1900,
        };

        const personKeys = Object.keys(personObj);
        
        for(let i = 0; i < personKeys.length; i++){
            const curkey = personKeys[i];
            const curValue = personObj[curkey];

            console.log(`${curkey} : ${curValue}`);
        }

        // 키 이름 말고 값만 순회시키고 싶을 때
        const personValues = Object.values(personObj);

        for(let i = 0; i < personValues.length; i++){
            console.log(personValues[i]);
        }

        // 배열 내장함수
        const arrArray = [1, 2, 3 ,4];

        arrArray.forEach((elm) => console.log(elm));

        const newArr = arrArray.map((elm) => {return elm * 2});

        let number = 3;
        console.log(arrArray.includes(number));

        console.log(arrArray.indexOf(number));

        const arrObj = [
            { num: 1, color : "red" },
            { num: 2, color : "black" },
            { num: 3, color : "blue" },
            { num: 4, color : "green" },
            { num: 5, color : "blue" },
        ];

        console.log(arrObj.findIndex((elm) => {elm.color === "green"}));

        const element = arrObj.find((elm) => {return elm.color === "blue"});
        console.log(element);

        console.log(arrObj.filter((elm) => elm.color === "blue"));

        console.log(arrObj.slice(0, 2));

        const arrObj2 = [
        { num: 6, color : "red" },
        { num: 7, color : "black" },
        ]

        console.log(arrObj.concat(arrObj2));

        let chars = ["나", "다", "라"];
        chars.sort();  
        console.log(chars);
        
        let numbers = [0, 1, 20, 13, 5, 28, 19];

        const compare = (a, b) => {
            if (a > b) {
                return -1;
            }
            if (a < b) {
                return 1;
            }
            return 0;
        }

        numbers.sort(compare);     // 숫자는 비교함수를 만들어서 정렬
        console.log(numbers);

        const arrJoin = ["나", "다", "라"]; 

        console.log(arrJoin.join());    // arrJoin.join() => () 안에는 구분자로 이용할 것을 넣음
    </script>
</body>
</html>