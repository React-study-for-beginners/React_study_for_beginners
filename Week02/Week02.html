<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>한입 크기로 잘라 먹는 리액트 2주차</title>
</head>
<body>
    <h1>2주차 강의 내용</h1>

    <h2>Truthy Falsy</h2>
    <span>
        자바스크립트가 특정 기준을 가지고 참이나 거짓 값을 분류
        불리언 식이 아니여도 평가 값을 낼 수 있다.
        Truthy: 참 같은 값
        Falsy: 거짓 같은 값
    </span>

    <h2>삼항 연산자</h2>
    <span>
        조건식 ? 참일 때 값 : 거짓일 때 값;
    </span>

    <h2>단락 회로 평가</h2>
    <span>
        논리 연산자(&&, ||, !)를 이용한 평가
        왼쪽에서 오른쪽으로 연산하는 논리 연산자의 연산 순서를 이용하는 이용하는 문법
    </span>

    <h2>조건문 업그레이드</h2>
    <span>
        includes() : 파라미터가 배열안에 존재하면 true
    </span>

    <h2>비구조화 할당 (구조분해 할당)</h2>    
    <span>
        순서대로 배열의 요소를 쉽게 할당할 수 있는 방법
        four='four' → 할당 시 기본값 설정 방법

        두 개 변수의 값을 바꾸는 스왑에도 활용 가능

        배열은 인덱스를 기준으로 할당을 하고, 객체는 키 값을 기준으로 할당
    </span>

    <h2>spread 연산자</h2>
    <span>
        ...을 사용하여 객체를 펼치는 역할
        배열의 원소를 순서대로 펼치는 역할 => 합쳐서 새로운 배열로 만들수도 있음
    </span>
    
    <h2>동기 / 비동기</h2>
    <span>
        - 동기 방식 처리
        자바스크립트는 코드가 작성된 순서대로 작업을 처리
        이전 작업이 진행 중일 때는 다음 작업을 수행하지 않고 기다림
        먼저 작성된 코드를 다 실행하고 나서 뒤에 작성된 코드를 실행

        동기 처리는 하나의 작업이 오래 걸리게 되면 모든 작업이 밀리거나 멈추기 때문에 전반적인 흐름이 느려짐

        쓰레드를 여러 개 사용하는 방식인 'MultiThread' 방식을 사용하면 작업 분할이 가능하겠지만 자바스크립트는 싱글 쓰레드임

        - 비동기 방식 처리
        싱글 쓰레드 방식을 이용하면서, 동기적 작업의 단점을 극복하기 위해 여러 개의 작업을 동시에 실행
        먼저 작성된 코드의 결과를 기다리지 않고 다음 코드를 바로 실행
        
        비동기 처리 결과를 이용할 땐 콜백 함수를 이용할 수 있음

        - 자바스크립트 엔진
        힙 : 변수나 상수들에 사용되는 메모리 저장 영역
        콜 스택 : 작성한 코드에 따라서 호출 스택을 쌓는 영역
    </span>

    <h2>Promise</h2>
    <span>
        자바스크립트의 비동기를 돕는 객체

        비동기 작업은 대기상태 Pending, 성공 Fulfilled, 실패 Rejected 상태를 가질 수 있음
        비동기 작업이 대기 상태에서 성공했다 → resolve
        비동기 작업이 대기 상태에서 실패했다 → reject
    </span>

    <h2>async / await</h2>
    <span>
        async는 promise의 resolve와 비슷 
        await는 비동기 함수 앞에 붙이면 동기 함수처럼 작동함 => 그 줄은 모두 동기적으로 움직임
        await은 async가 붙은 함수에서만 사용 가능
    </span>

    <h2>API / fetch</h2>
    <span>
        - API
        Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스
        응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
        주로 파일제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공
        API 호출은 다른 프로그램에게 데이터를 받기 위해 신호를 보내는 것이지만 언제 데이터를 받을 수 있을지는 모름

        JSONPlaceholder - Free Fake REST API

        - fetch
        API를 호출할 수 있게 도와주는 내장 함수
    </span>

    <script>
        const getName = (person) => {
            if (!person) {  // false NOT => true 
                return "객체가 아님";
            }
            return person.name;
        };
        let person;
        const name = getName(person);
        console.log(name);

        let a = -3;
        a >= 0 ? console.log("양수") : console.log("음수");

        const meal = {
            한식: "불고기",
            중식: "짜장면",
            일식: "초밥",
            양식: "스테이크",
            인도식: "카레",
        };
        const getMeal = (mealType) => {
            return meal[mealType] || "굶기";
        };
        console.log(getMeal("중식"));

        let arr = ["one", "two", "three"];
        let [one, two, three] = arr;

        let [one1, two1, three1, four='four'] = ["one", "two", "three"];    // 배열의 선언 분리

        let c = 10;
        let d = 20;
        let tmp = 0;
        tmp = c;
        c = d;
        d = tmp;
        console.log(c, d);  // 20 10

        [c, d] = [d, c];     //  비구조화 할당 스왑

        let { name: myName , one: oneOne , two2, three2} = object;  // one: oneOne 기존 키 변수명 변경 가능

        const cookie = {
            base: "cookie",
            madeIn: "korea",
        };

        const chocochipCookie = {
            ...cookie,
            toping: "chocochip",
        };
        const blueberryCookie = {
            ...cookie,
            toping: "blueberry",
        };

        function taskA(){
            setTimeout(()=>{
                console.log("A task end");
            },2000)
        }
        taskA();
        console.log("코드 끝");     
        // 코드 끝
        // A task end

        function isPositive(number, resolve, reject){
            setTimeout(() => {
                if (typeof number === " number"){
                    resolve(number >= 0 ? "상수" : "음수");
                } else {
                    reject("숫자가 아님");
                }
            }, 2000);
        }
        // isPositive(
        //     [],
        //     (res) => {
        //         console.log("성공적으로 수행됨 : ", res);
        //     },
        //     (err) => {
        //         console.log("실패 :", err);
        //     }
        // );
        function isPositiveP(number){
            const executor = (resolve, reject) => {
                setTimeout(() => {
                    if (typeof number === " number"){
                        resolve(number >= 0 ? "상수" : "음수");
                    } else {
                        reject("숫자가 아님");
                    }
                }, 2000);
            };
            const asyncTask = new Promise(executor);
            return asyncTask;
        }
        const res =  isPositiveP(101);
        res.then((res) => {     // resolve 수행하고 받아올 때 then
            console.log("성공적으로 수행됨 : ", res);
        }).catch((err) => {     // reject 수행하고 받아올 때 catch
            console.log("실패 :", err);
        });

        async function getData(){
            let rawResponse = await fetch("API 주소 입력");
            let jsonResponse = await rawResponse.json();
            console.log(jsonResponse);
        }
        getData();
        // let response = fetch("API 주소 입력").then((res) => {
        //     console.log(res)
        // });
    </script>
</body>
</html>